{"version":3,"sources":["../src/NarrowPhase.js"],"names":["tempAABB","tempAABB2","NarrowPhase","collisionMap","pool","tickId","currentCollisions","contactPool","collisionDatas","CIRCLE","RECTANGLE","rectangleVrectangle","LINE","lineVline","rectangleVline","circleVline","collide","collisions","i","length","bounds","body1","globalBounds","bounds2","body2","aabbVaabb","shapes","shape1","j","shape2","type","collisionSuccess","collisionsFail","collisonData","_tickId","endCollision","splice","penetration","projection","key","UID","contactData","pop","CrashData","object1","object2","ignore","_key","push","circle1","circle2","aabb1","aabb2","lower1","lower","upper1","upper","lower2","upper2","x","y","collisionData","world","reset"],"mappings":"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","file":"NarrowPhase.js","sourcesContent":["\nimport Vector from './Vector';\nimport AABB from './AABB';\nimport ContactData from './ContactData';\n\nimport Shape from './shapes/Shape';\nimport circleVcircle from './collision/circleVcircle';\nimport rectangleVcircle from './collision/rectangleVcircle';\n\n\nconst tempAABB = new AABB();\nconst tempAABB2 = new AABB();\n\nexport default class NarrowPhase\n{\n    constructor()\n    {\n        this.collisionMap = {};\n\n        this.pool = [];\n\n        this.tickId = 0;\n\n        this.currentCollisions = [];\n        this.contactPool = [];\n\n        this.collisionDatas = [];\n\n        this[Shape.CIRCLE | Shape.CIRCLE] = circleVcircle;\n        this[Shape.RECTANGLE | Shape.RECTANGLE] = this.rectangleVrectangle;\n        this[Shape.LINE | Shape.LINE] = this.lineVline;\n        this[Shape.RECTANGLE | Shape.CIRCLE] = rectangleVcircle;\n        this[Shape.RECTANGLE | Shape.LINE] = this.rectangleVline;\n        this[Shape.CIRCLE | Shape.LINE] = this.circleVline;\n    }\n\n\n    collide(collisions)\n    {\n        this.tickId ++;\n\n        //TODO OPTIMISE THIS SHIZ\n        //for(var j = 0; j < 1; j++)\n        //{\n        for (var i = 0; i < collisions.length; i+=2)\n        {\n            // first aabb checks..\n\n            const bounds = body1.globalBounds(collisions[i])\n            const bounds2 = body2.globalBounds(collisions[i+1])\n\n            if(this.aabbVaabb(bounds, bounds2))\n            {\n                for (var i = 0; i < body1.shapes.length; i++)\n                {\n                    const shape1 = body1.shapes[i];\n\n                    for (var j = 0; j < body2.shapes.length; j++)\n                    {\n                        const shape2 = body2.shapes[j];\n\n                        if(shape1.type < shape2.type)\n                        {\n                            this[shape1.type | shape2.type](\n                                body1,\n                                shape1,\n                                body2,\n                                shape2,\n                                this.collisionSuccess,\n                                this.collisionsFail\n                            );\n                        }\n                        else\n                        {\n                            this[shape2.type | shape1.type](\n                                body2,\n                                shape2,\n                                body1,\n                                shape1,\n                                this.collisionSuccess,\n                                this.collisionsFail\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        // check for dead collisons..\n        for (var i = 0; i < this.currentCollisions.length; i++) {\n\n            var collisonData = this.currentCollisions[i];\n\n            if(collisonData._tickId !== this.tickId)\n            {\n                // ended!\n                this.endCollision( collisonData );\n                this.currentCollisions.splice(i, 1);\n                i--;\n            }\n\n        };\n    }\n\n    collisionSuccess(body1, shape1, body2, shape2, penetration, projection)\n    {\n        var key;\n\n        if(shape1.UID > shape2.UID)\n        {\n            key = (shape2.UID << 12) + shape1.UID;//shape1.UID + \":\"+ shape2.UID;\n        }\n        else\n        {\n            key = (shape1.UID << 12) + shape2.UID;//shape1.UID + \":\"+ object2.UID;\n\n        }\n\n        var contactData = this.collisionMap[key];\n\n        if( contactData )\n        {\n            contactData.penetration = penetration;\n            contactData.projection = projection;\n            contactData._tickId = this.tickId;\n        }\n        else\n        {\n            contactData = this.pool.pop();\n\n            if(!contactData)\n            {\n                contactData = new CrashData(object1,\n                                            object2,\n                                            penetration,\n                                            projection,\n                                            false);\n            }\n            else\n            {\n                contactData.object1 = object1;\n                contactData.object2 = object2;\n                contactData.penetration = penetration;\n                contactData.projection = projection;\n                contactData.ignore = false;\n            }\n\n            contactData._key = key;\n            contactData._tickId = this.tickId;\n\n            this.collisionMap[key] = contactData;\n\n            this.currentCollisions.push(contactData);\n\n        }\n    }\n\n    collisionsFail(body1, circle1, body2, circle2)\n    {\n        // no more collision!\n    }\n\n    aabbVaabb(aabb1, aabb2)\n    {\n        const lower1 = aabb1.lower;\n        const upper1 = aabb1.upper;\n        const lower2 = aabb2.lower;\n        const upper2 = aabb2.upper;\n\n        return ((lower2.x <= upper1.x && upper1.x <= upper2.x) || (lower1.x <= upper2.x && upper2.x <= upper1.x)) &&\n               ((lower2.y <= upper1.y && upper1.y <= upper2.y) || (lower1.y <= upper2.y && upper2.y <= upper1.y));\n    }\n\n    endCollision(collisionData)\n    {\n\n        var key = collisionData._key\n\n        var collisonData = this.collisions[key];\n\n        if( collisonData )\n        {\n            // end collision..\n/*\n            if(collisionData.object2 === collisionData.object1.body.currentSurface)\n            {\n                collisionData.object1.onGround = false;\n                collisionData.object1.body.currentSurface = null;\n            }\n            else if(collisionData.object1 === collisionData.object2.body.currentSurface)\n            {\n                collisionData.object2.onGround = false;\n                collisionData.object2.body.currentSurface = null;\n            }\n*/\n            this.pool.push( collisonData );\n            this.collisions[key] = null;\n\n        }\n\n        //TODO think about this!\n        if(collisionData.object1.world)\n        {\n\n           // if(collisionData.object1.onCollideEnd)collisionData.object1.onCollideEnd(collisonData);\n           // if(collisionData.object2.onCollideEnd)collisionData.object2.onCollideEnd(collisonData);\n        }\n\n\n       return collisonData;\n    }\n\n    reset()\n    {\n        this.collisions ={};\n        this.tickId = 0;\n\n        this.currentCollisions = [];\n    }\n}"]}