{"version":3,"sources":["../src/NarrowPhase.js"],"names":["tempAABB","tempAABB2","NarrowPhase","collisionMap","pool","tickId","currentCollisions","contactPool","collisionDatas","CIRCLE","RECTANGLE","rectangleVrectangle","LINE","lineVline","rectangleVline","circleVline","collisions","i","length","bounds","body1","globalBounds","bounds2","body2","aabbVaabb","shapes","shape1","j","shape2","type","collisionSuccess","collisionsFail","collisonData","_tickId","endCollision","splice","penetration","projection","key","UID","contactData","pop","CrashData","object1","object2","ignore","_key","push","circle1","circle2","aabb1","aabb2","lower1","lower","upper1","upper","lower2","upper2","x","y","collisionData","world"],"mappings":"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","file":"NarrowPhase.js","sourcesContent":["\nimport Vector from './Vector';\nimport AABB from './AABB';\nimport ContactData from './ContactData';\n\nimport Shape from './shapes/Shape';\nimport circleVcircle from './collision/circleVcircle';\nimport rectangleVcircle from './collision/rectangleVcircle';\n\n\nconst tempAABB = new AABB();\nconst tempAABB2 = new AABB();\n\nexport default class NarrowPhase\n{\n    constructor()\n    {\n        this.collisionMap = {};\n\n        this.pool = [];\n\n        this.tickId = 0;\n\n        this.currentCollisions = [];\n        this.contactPool = [];\n\n        this.collisionDatas = [];\n\n        this[Shape.CIRCLE | Shape.CIRCLE] = circleVcircle;\n        this[Shape.RECTANGLE | Shape.RECTANGLE] = this.rectangleVrectangle;\n        this[Shape.LINE | Shape.LINE] = this.lineVline;\n        this[Shape.RECTANGLE | Shape.CIRCLE] = rectangleVcircle;\n        this[Shape.RECTANGLE | Shape.LINE] = this.rectangleVline;\n        this[Shape.CIRCLE | Shape.LINE] = this.circleVline;\n    }\n\n\n    collide(collisions)\n    {\n        this.tickId ++;\n\n        //TODO OPTIMISE THIS SHIZ\n        //for(var j = 0; j < 1; j++)\n        //{\n        for (var i = 0; i < collisions.length; i+=2)\n        {\n            // first aabb checks..\n\n            const bounds = body1.globalBounds(collisions[i])\n            const bounds2 = body2.globalBounds(collisions[i+1])\n\n            if(this.aabbVaabb(bounds, bounds2))\n            {\n                for (var i = 0; i < body1.shapes.length; i++)\n                {\n                    const shape1 = body1.shapes[i];\n\n                    for (var j = 0; j < body2.shapes.length; j++)\n                    {\n                        const shape2 = body2.shapes[j];\n\n                        if(shape1.type < shape2.type)\n                        {\n                            this[shape1.type | shape2.type](\n                                body1,\n                                shape1,\n                                body2,\n                                shape2,\n                                this.collisionSuccess,\n                                this.collisionsFail\n                            );\n                        }\n                        else\n                        {\n                            this[shape2.type | shape1.type](\n                                body2,\n                                shape2,\n                                body1,\n                                shape1,\n                                this.collisionSuccess,\n                                this.collisionsFail\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        // check for dead collisons..\n        for (var i = 0; i < this.currentCollisions.length; i++) {\n\n            var collisonData = this.currentCollisions[i];\n\n            if(collisonData._tickId !== this.tickId)\n            {\n                // ended!\n                this.endCollision( collisonData );\n                this.currentCollisions.splice(i, 1);\n                i--;\n            }\n\n        };\n    }\n\n    collisionSuccess(body1, shape1, body2, shape2, penetration, projection)\n    {\n        var key;\n\n        if(shape1.UID > shape2.UID)\n        {\n            key = (shape2.UID << 12) + shape1.UID;//shape1.UID + \":\"+ shape2.UID;\n        }\n        else\n        {\n            key = (shape1.UID << 12) + shape2.UID;//shape1.UID + \":\"+ object2.UID;\n\n        }\n\n        var contactData = this.collisionMap[key];\n\n        if( contactData )\n        {\n            contactData.penetration = penetration;\n            contactData.projection = projection;\n            contactData._tickId = this.tickId;\n        }\n        else\n        {\n            contactData = this.pool.pop();\n\n            if(!contactData)\n            {\n                contactData = new CrashData(object1,\n                                            object2,\n                                            penetration,\n                                            projection,\n                                            false);\n            }\n            else\n            {\n                contactData.object1 = object1;\n                contactData.object2 = object2;\n                contactData.penetration = penetration;\n                contactData.projection = projection;\n                contactData.ignore = false;\n            }\n\n            contactData._key = key;\n            contactData._tickId = this.tickId;\n\n            this.collisionMap[key] = contactData;\n\n            this.currentCollisions.push(contactData);\n\n        }\n    }\n\n    collisionsFail(body1, circle1, body2, circle2)\n    {\n        // no more collision!\n    }\n\n    aabbVaabb(aabb1, aabb2)\n    {\n        const lower1 = aabb1.lower;\n        const upper1 = aabb1.upper;\n        const lower2 = aabb2.lower;\n        const upper2 = aabb2.upper;\n\n        return ((lower2.x <= upper1.x && upper1.x <= upper2.x) || (lower1.x <= upper2.x && upper2.x <= upper1.x)) &&\n               ((lower2.y <= upper1.y && upper1.y <= upper2.y) || (lower1.y <= upper2.y && upper2.y <= upper1.y));\n    }\n\n    endCollision(collisionData)\n    {\n\n        var key = collisionData._key\n\n        var collisonData = this.collisions[key];\n\n        if( collisonData )\n        {\n            // end collision..\n/*\n            if(collisionData.object2 === collisionData.object1.body.currentSurface)\n            {\n                collisionData.object1.onGround = false;\n                collisionData.object1.body.currentSurface = null;\n            }\n            else if(collisionData.object1 === collisionData.object2.body.currentSurface)\n            {\n                collisionData.object2.onGround = false;\n                collisionData.object2.body.currentSurface = null;\n            }\n*/\n            this.pool.push( collisonData );\n            this.collisions[key] = null;\n\n        }\n\n        //TODO think about this!\n        if(collisionData.object1.world)\n        {\n\n           // if(collisionData.object1.onCollideEnd)collisionData.object1.onCollideEnd(collisonData);\n           // if(collisionData.object2.onCollideEnd)collisionData.object2.onCollideEnd(collisonData);\n        }\n\n\n       return collisonData;\n    }\n\n    reset()\n    {\n        this.collisions ={};\n        this.tickId = 0;\n\n        this.currentCollisions = [];\n    }\n}"]}